<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# errors

```go
import "github.com/aexvir/skladka/internal/errors"
```

Package errors provides enhanced error handling primitives that extend Go's standard errors package. It offers stack traces, error wrapping, and HTTP error handling while maintaining compatibility with the standard library.

This is a copy of github.com/pkg/errors slightly updated and extended to support more modern logging approaches.

Key Features:

- Stack Traces: Automatically capture stack traces when errors are created
- Error Wrapping: Add context to errors while preserving the original error
- HTTP Errors: Structured error types for HTTP responses
- Error Joining: Combine multiple errors into a single error value

Basic Usage:

```
// Create a new error with stack trace
err := errors.New("database connection failed")

// Add context to an existing error
if err != nil {
    return errors.Wrap(err, "failed to initialize storage")
}

// Format error with stack trace
fmt.Printf("%+v\n", err)
```

Error Types:

```
fundamental - Base error type with stack trace
withStack  - Adds stack trace to an existing error
withMessage - Adds a message to an existing error
withMultierr - Combines multiple errors into one
HTTPError - HTTP-specific error with status code
```

Error Wrapping:

The package provides several ways to wrap errors:

```
errors.Wrap(err, "message")     // Add message and stack trace
errors.Wrapf(err, "fmt", args)  // Add formatted message and stack trace
errors.WithStack(err)           // Add only stack trace
errors.WithMessage(err, "msg")  // Add only message
```

Error Inspection:

Use these methods to inspect errors:

```
errors.Is(err, target)     // Check if err matches target
errors.As(err, &target)    // Try to convert err to target type
errors.Cause(err)          // Get the root cause of the error
```

HTTP Error Handling:

For HTTP services, use the HTTP error types:

```
errors.NewHTTPError(http.StatusNotFound, "user not found", err)
errors.AsHTTPError(err)  // Convert any error to an HTTPError
```

Formatting:

All error types implement fmt.Formatter and support:

```
%s    - Print the error message
%v    - Same as %s
%q    - Print the error message with quotes
%+v   - Print detailed error with stack trace
```

Error Joining:

Combine multiple errors into one:

```
err1 := errors.New("first error")
err2 := errors.New("second error")
combined := errors.Join(err1, err2)
```

Best Practices:

1. Always use errors.New\(\) instead of errors.New\(\) for new errors
2. Use errors.Wrap\(\) when adding context to returned errors
3. Use %\+v when logging errors to include stack traces
4. Use errors.Is\(\) and errors.As\(\) for error inspection
5. Use HTTPError types for HTTP API responses

<details><summary>Example (Stack Trace)</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func fn() error {
	e1 := errors.New("error")
	e2 := errors.Wrap(e1, "inner")
	e3 := errors.Wrap(e2, "middle")
	return errors.Wrap(e3, "outer")
}

func main() {
	type stackTracer interface {
		StackTrace() errors.StackTrace
	}

	err, ok := errors.Cause(fn()).(stackTracer)
	if !ok {
		panic("oops, err does not implement stackTracer")
	}

	st := err.StackTrace()
	fmt.Printf("%+v", st[0:2]) // top two frames

	// Example output:
	// github.com/pkg/errors_test.fn
	//	/home/dfc/src/github.com/pkg/errors/example_test.go:47
	// github.com/pkg/errors_test.Example_stackTrace
	//	/home/dfc/src/github.com/pkg/errors/example_test.go:127
}
```

</p>
</details>

## Index

- [Variables](<#variables>)
- [func As\(err error, target any\) bool](<#As>)
- [func Cause\(err error\) error](<#Cause>)
- [func Errorf\(format string, args ...interface\{\}\) error](<#Errorf>)
- [func Is\(err, target error\) bool](<#Is>)
- [func IsBadRequest\(err error\) bool](<#IsBadRequest>)
- [func IsForbidden\(err error\) bool](<#IsForbidden>)
- [func IsInternalServer\(err error\) bool](<#IsInternalServer>)
- [func IsNotFound\(err error\) bool](<#IsNotFound>)
- [func IsUnauthorized\(err error\) bool](<#IsUnauthorized>)
- [func Join\(errs ...error\) error](<#Join>)
- [func New\(message string\) error](<#New>)
- [func NewHTTPError\(code int, message string, err error\) error](<#NewHTTPError>)
- [func WithMessage\(err error, message string\) error](<#WithMessage>)
- [func WithMessagef\(err error, format string, args ...interface\{\}\) error](<#WithMessagef>)
- [func WithStack\(err error\) error](<#WithStack>)
- [func Wrap\(err error, message string\) error](<#Wrap>)
- [func Wrapf\(err error, format string, args ...interface\{\}\) error](<#Wrapf>)
- [type Frame](<#Frame>)
  - [func \(f Frame\) Format\(state fmt.State, verb rune\)](<#Frame.Format>)
  - [func \(f Frame\) MarshalText\(\) \(\[\]byte, error\)](<#Frame.MarshalText>)
- [type HTTPError](<#HTTPError>)
  - [func AsHTTPError\(err error\) \*HTTPError](<#AsHTTPError>)
  - [func \(e \*HTTPError\) Error\(\) string](<#HTTPError.Error>)
  - [func \(e \*HTTPError\) Format\(s fmt.State, verb rune\)](<#HTTPError.Format>)
  - [func \(e \*HTTPError\) Is\(target error\) bool](<#HTTPError.Is>)
  - [func \(e \*HTTPError\) Unwrap\(\) error](<#HTTPError.Unwrap>)
- [type StackTrace](<#StackTrace>)
  - [func \(st StackTrace\) Format\(state fmt.State, verb rune\)](<#StackTrace.Format>)


## Variables

<a name="ErrNotFound"></a>

```go
var (
    // Common application errors
    ErrNotFound           = NewHTTPError(http.StatusNotFound, "Resource not found", nil)
    ErrBadRequest         = NewHTTPError(http.StatusBadRequest, "Bad request", nil)
    ErrUnauthorized       = NewHTTPError(http.StatusUnauthorized, "Unauthorized", nil)
    ErrForbidden          = NewHTTPError(http.StatusForbidden, "Forbidden", nil)
    ErrInternalServer     = NewHTTPError(http.StatusInternalServerError, "Internal server error", nil)
    ErrServiceUnavailable = NewHTTPError(http.StatusServiceUnavailable, "Service unavailable", nil)
)
```

<a name="As"></a>
## func [As](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L192>)

```go
func As(err error, target any) bool
```

As finds the first error in err's chain that matches target, and if one is found, As returns true and sets target to that error value. Otherwise, As returns false and sets target to nil.

<a name="Cause"></a>
## func [Cause](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L137>)

```go
func Cause(err error) error
```

Cause returns the underlying cause of the error, if possible. An error value has a cause if it implements the following interface:

```
type causer interface {
    Cause() error
}
```

If the error does not implement Cause, the original error will be returned. If the error is nil, nil will be returned without further investigation.

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func fn() error {
	e1 := errors.New("error")
	e2 := errors.Wrap(e1, "inner")
	e3 := errors.Wrap(e2, "middle")
	return errors.Wrap(e3, "outer")
}

func main() {
	err := fn()
	fmt.Println(err)
	fmt.Println(errors.Cause(err))

}
```

#### Output

```
outer: middle: inner: error
error
```

</p>
</details>

<details><summary>Example (Printf)</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func main() {
	err := errors.Wrap(func() error {
		return func() error {
			return errors.New("hello world")
		}()
	}(), "failed")

	fmt.Printf("%v", err)

}
```

#### Output

```
failed: hello world
```

</p>
</details>

<a name="Errorf"></a>
## func [Errorf](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L27>)

```go
func Errorf(format string, args ...interface{}) error
```

Errorf returns a new error with formatted message and a stack trace. The error implements fmt.Formatter for custom error formatting.

```
name := "db"
err := errors.Errorf("connection to %s failed", name)
```

<details><summary>Example (Extended)</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func main() {
	err := errors.Errorf("whoops: %s", "foo")
	fmt.Printf("%+v", err)

	// Example output:
	// whoops: foo
	// github.com/pkg/errors_test.ExampleErrorf
	//         /home/dfc/src/github.com/pkg/errors/example_test.go:101
	// testing.runExample
	//         /home/dfc/go/src/testing/example.go:114
	// testing.RunExamples
	//         /home/dfc/go/src/testing/example.go:38
	// testing.(*M).Run
	//         /home/dfc/go/src/testing/testing.go:744
	// main.main
	//         /github.com/pkg/errors/_test/_testmain.go:102
	// runtime.main
	//         /home/dfc/go/src/runtime/proc.go:183
	// runtime.goexit
	//         /home/dfc/go/src/runtime/asm_amd64.s:2059
}
```

</p>
</details>

<a name="Is"></a>
## func [Is](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L198>)

```go
func Is(err, target error) bool
```

Is reports whether any error in errs matches target. An error matches target if the error values are identical, as determined by ==.

<a name="IsBadRequest"></a>
## func [IsBadRequest](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L121>)

```go
func IsBadRequest(err error) bool
```

IsBadRequest returns true if the error is a bad request error

<a name="IsForbidden"></a>
## func [IsForbidden](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L133>)

```go
func IsForbidden(err error) bool
```

IsForbidden returns true if the error is a forbidden error

<a name="IsInternalServer"></a>
## func [IsInternalServer](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L139>)

```go
func IsInternalServer(err error) bool
```

IsInternalServer returns true if the error is an internal server error

<a name="IsNotFound"></a>
## func [IsNotFound](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L115>)

```go
func IsNotFound(err error) bool
```

IsNotFound returns true if the error is a not found error

<a name="IsUnauthorized"></a>
## func [IsUnauthorized](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L127>)

```go
func IsUnauthorized(err error) bool
```

IsUnauthorized returns true if the error is an unauthorized error

<a name="Join"></a>
## func [Join](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L167>)

```go
func Join(errs ...error) error
```

Join returns an error that wraps the given errors. Any nil error values are discarded. Join returns nil if errs contains no non\-nil values. The error formats as the concatenation of the strings obtained by calling the Error method of each element of errs, with a newline between each string.

```
err1 := errors.New("first error")
err2 := errors.New("second error")
err := errors.Join(err1, err2)
fmt.Printf("%v", err)
// Output:
// first error
// second error
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func main() {
	err1 := errors.New("error 1")
	err2 := errors.Wrap(errors.New("inner"), "error 2")

	err := errors.Join(err1, err2)
	fmt.Printf("%v\n", err)
}
```

#### Output

```
error 1
error 2: inner
```

</p>
</details>

<a name="New"></a>
## func [New](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L15>)

```go
func New(message string) error
```

New returns a new error with a stack trace. The error implements fmt.Formatter for custom error formatting.

```
err := errors.New("connection failed")
fmt.Printf("%+v", err) // prints error with stack trace
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func main() {
	err := errors.New("whoops")
	fmt.Println(err)

}
```

#### Output

```
whoops
```

</p>
</details>

<details><summary>Example (Printf)</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func main() {
	err := errors.New("whoops")
	fmt.Printf("%+v", err)

	// Example output:
	// whoops
	// github.com/pkg/errors_test.ExampleNew_printf
	//         /home/dfc/src/github.com/pkg/errors/example_test.go:17
	// testing.runExample
	//         /home/dfc/go/src/testing/example.go:114
	// testing.RunExamples
	//         /home/dfc/go/src/testing/example.go:38
	// testing.(*M).Run
	//         /home/dfc/go/src/testing/testing.go:744
	// main.main
	//         /github.com/pkg/errors/_test/_testmain.go:106
	// runtime.main
	//         /home/dfc/go/src/runtime/proc.go:183
	// runtime.goexit
	//         /home/dfc/go/src/runtime/asm_amd64.s:2059
}
```

</p>
</details>

<a name="NewHTTPError"></a>
## func [NewHTTPError](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L75>)

```go
func NewHTTPError(code int, message string, err error) error
```

NewHTTPError creates a new HTTPError with the given code and message. If err is not nil, it will be wrapped and accessible via Unwrap\(\).

```
err := errors.NewHTTPError(http.StatusNotFound, "user not found", nil)
err = errors.NewHTTPError(http.StatusInternalServerError, "database error", dbErr)
```

<a name="WithMessage"></a>
## func [WithMessage](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L99>)

```go
func WithMessage(err error, message string) error
```

WithMessage annotates err with a new message. If err is nil, WithMessage returns nil.

```
err := doSomething()
if err != nil {
    return errors.WithMessage(err, "failed to do something")
}
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func main() {
	cause := errors.New("whoops")
	err := errors.WithMessage(cause, "oh noes")
	fmt.Println(err)

}
```

#### Output

```
oh noes: whoops
```

</p>
</details>

<a name="WithMessagef"></a>
## func [WithMessagef](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L117>)

```go
func WithMessagef(err error, format string, args ...interface{}) error
```

WithMessagef annotates err with the format specifier. If err is nil, WithMessagef returns nil.

```
err := doSomething()
if err != nil {
    return errors.WithMessagef(err, "failed to do something: %s", details)
}
```

<a name="WithStack"></a>
## func [WithStack](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L82>)

```go
func WithStack(err error) error
```

WithStack annotates err with a stack trace at the point WithStack was called. If err is nil, WithStack returns nil.

```
if err != nil {
    return errors.WithStack(err)
}
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func main() {
	cause := errors.New("whoops")
	err := errors.WithStack(cause)
	fmt.Println(err)

}
```

#### Output

```
whoops
```

</p>
</details>

<details><summary>Example (Printf)</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func main() {
	cause := errors.New("whoops")
	err := errors.WithStack(cause)
	fmt.Printf("%+v", err)

	// Example Output:
	// whoops
	// github.com/pkg/errors_test.ExampleWithStack_printf
	//         /home/fabstu/go/src/github.com/pkg/errors/example_test.go:55
	// testing.runExample
	//         /usr/lib/go/src/testing/example.go:114
	// testing.RunExamples
	//         /usr/lib/go/src/testing/example.go:38
	// testing.(*M).Run
	//         /usr/lib/go/src/testing/testing.go:744
	// main.main
	//         github.com/pkg/errors/_test/_testmain.go:106
	// runtime.main
	//         /usr/lib/go/src/runtime/proc.go:183
	// runtime.goexit
	//         /usr/lib/go/src/runtime/asm_amd64.s:2086
	// github.com/pkg/errors_test.ExampleWithStack_printf
	//         /home/fabstu/go/src/github.com/pkg/errors/example_test.go:56
	// testing.runExample
	//         /usr/lib/go/src/testing/example.go:114
	// testing.RunExamples
	//         /usr/lib/go/src/testing/example.go:38
	// testing.(*M).Run
	//         /usr/lib/go/src/testing/testing.go:744
	// main.main
	//         github.com/pkg/errors/_test/_testmain.go:106
	// runtime.main
	//         /usr/lib/go/src/runtime/proc.go:183
	// runtime.goexit
	//         /usr/lib/go/src/runtime/asm_amd64.s:2086
}
```

</p>
</details>

<a name="Wrap"></a>
## func [Wrap](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L41>)

```go
func Wrap(err error, message string) error
```

Wrap returns an error annotating err with a stack trace at the point Wrap is called, and the supplied message. If err is nil, Wrap returns nil.

```
err := doSomething()
if err != nil {
    return errors.Wrap(err, "failed to do something")
}
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func main() {
	cause := errors.New("whoops")
	err := errors.Wrap(cause, "oh noes")
	fmt.Println(err)

}
```

#### Output

```
oh noes: whoops
```

</p>
</details>

<details><summary>Example (Extended)</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func fn() error {
	e1 := errors.New("error")
	e2 := errors.Wrap(e1, "inner")
	e3 := errors.Wrap(e2, "middle")
	return errors.Wrap(e3, "outer")
}

func main() {
	err := fn()
	fmt.Printf("%+v\n", err)

	// Example output:
	// error
	// github.com/pkg/errors_test.fn
	//         /home/dfc/src/github.com/pkg/errors/example_test.go:47
	// github.com/pkg/errors_test.ExampleCause_printf
	//         /home/dfc/src/github.com/pkg/errors/example_test.go:63
	// testing.runExample
	//         /home/dfc/go/src/testing/example.go:114
	// testing.RunExamples
	//         /home/dfc/go/src/testing/example.go:38
	// testing.(*M).Run
	//         /home/dfc/go/src/testing/testing.go:744
	// main.main
	//         /github.com/pkg/errors/_test/_testmain.go:104
	// runtime.main
	//         /home/dfc/go/src/runtime/proc.go:183
	// runtime.goexit
	//         /home/dfc/go/src/runtime/asm_amd64.s:2059
	// github.com/pkg/errors_test.fn
	// 	  /home/dfc/src/github.com/pkg/errors/example_test.go:48: inner
	// github.com/pkg/errors_test.fn
	//        /home/dfc/src/github.com/pkg/errors/example_test.go:49: middle
	// github.com/pkg/errors_test.fn
	//      /home/dfc/src/github.com/pkg/errors/example_test.go:50: outer
}
```

</p>
</details>

<a name="Wrapf"></a>
## func [Wrapf](<https://github.com/aexvir/skladka/blob/master/internal/errors/errors.go#L62>)

```go
func Wrapf(err error, format string, args ...interface{}) error
```

Wrapf returns an error annotating err with a stack trace at the point Wrapf is called, and the format specifier. If err is nil, Wrapf returns nil.

```
err := doSomething()
if err != nil {
    return errors.Wrapf(err, "failed to do something: %s", details)
}
```

<details><summary>Example</summary>
<p>



```go
package main

import (
	"fmt"

	"github.com/aexvir/skladka/internal/errors"
)

func main() {
	cause := errors.New("whoops")
	err := errors.Wrapf(cause, "oh noes #%d", 2)
	fmt.Println(err)

}
```

#### Output

```
oh noes #2: whoops
```

</p>
</details>

<a name="Frame"></a>
## type [Frame](<https://github.com/aexvir/skladka/blob/master/internal/errors/stack.go#L58>)

Frame represents a program counter inside a stack frame. For historical reasons if Frame is interpreted as a uintptr its value represents the program counter \+ 1.

```go
type Frame uintptr
```

<a name="Frame.Format"></a>
### func \(Frame\) [Format](<https://github.com/aexvir/skladka/blob/master/internal/errors/stack.go#L72>)

```go
func (f Frame) Format(state fmt.State, verb rune)
```

Format formats the frame according to the fmt.Formatter interface.

```
%s    source file
%d    source line
%n    function name
%v    equivalent to %s:%d
```

Format accepts flags that alter the printing of some verbs, as follows:

```
%+s   function name and path of source file relative to the compile time
      GOPATH separated by \n\t (<funcname>\n\t<path>)
%+v   equivalent to %+s:%d
```

<a name="Frame.MarshalText"></a>
### func \(Frame\) [MarshalText](<https://github.com/aexvir/skladka/blob/master/internal/errors/stack.go#L96>)

```go
func (f Frame) MarshalText() ([]byte, error)
```

MarshalText formats a stacktrace Frame as a text string. The output is the same as that of fmt.Sprintf\("%\+v", f\), but without newlines or tabs.

<a name="HTTPError"></a>
## type [HTTPError](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L21-L26>)

HTTPError represents an error that includes an HTTP status code. It implements error, fmt.Formatter, and errors.Unwrap interfaces. The error can be formatted with %s, %q, %v, and %\+v verbs.

Example usage:

```
err := errors.NewHTTPError(http.StatusNotFound, "user not found", nil)
fmt.Printf("%+v\n", err) // prints detailed error with stack trace
fmt.Printf("%v\n", err)  // prints "user not found"
fmt.Printf("%q\n", err)  // prints "\"user not found\""
```

```go
type HTTPError struct {
    Code    int    `json:"code"`
    Message string `json:"message"`
    // contains filtered or unexported fields
}
```

<a name="AsHTTPError"></a>
### func [AsHTTPError](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L91>)

```go
func AsHTTPError(err error) *HTTPError
```

AsHTTPError attempts to convert an error to an HTTPError. If the error is already an HTTPError, it is returned as is. If the error is not an HTTPError, it is wrapped as an internal server error.

```
err := someFunction()
httpErr := errors.AsHTTPError(err)
fmt.Printf("Status code: %d\n", httpErr.Code)
```

<a name="HTTPError.Error"></a>
### func \(\*HTTPError\) [Error](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L28>)

```go
func (e *HTTPError) Error() string
```



<a name="HTTPError.Format"></a>
### func \(\*HTTPError\) [Format](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L41>)

```go
func (e *HTTPError) Format(s fmt.State, verb rune)
```



<a name="HTTPError.Is"></a>
### func \(\*HTTPError\) [Is](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L62>)

```go
func (e *HTTPError) Is(target error) bool
```

Is reports whether this error matches target. An error matches if both the Code and Message are equal.

<a name="HTTPError.Unwrap"></a>
### func \(\*HTTPError\) [Unwrap](<https://github.com/aexvir/skladka/blob/master/internal/errors/http.go#L37>)

```go
func (e *HTTPError) Unwrap() error
```

Unwrap implements the errors.Unwrap interface. This allows the error to work with errors.Is, errors.As and errors.Unwrap.

<a name="StackTrace"></a>
## type [StackTrace](<https://github.com/aexvir/skladka/blob/master/internal/errors/stack.go#L13>)

StackTrace is stack of Frames from innermost \(newest\) to outermost \(oldest\).

```go
type StackTrace []Frame
```

<a name="StackTrace.Format"></a>
### func \(StackTrace\) [Format](<https://github.com/aexvir/skladka/blob/master/internal/errors/stack.go#L23>)

```go
func (st StackTrace) Format(state fmt.State, verb rune)
```

Format formats the stack of Frames according to the fmt.Formatter interface.

```
%s	lists source files for each Frame in the stack
%v	lists the source file and line number for each Frame in the stack
```

Format accepts flags that alter the printing of some verbs, as follows:

```
%+v   Prints filename, function, and line number for each Frame in the stack.
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
